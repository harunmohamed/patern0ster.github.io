<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Positive Tree In Haskell ::
        DevBlog â€” Mete Karasakal
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Introduction ðŸŒ² This is a project builds positive tree by adding/multiplying elements in pairs from bottom to top and there are functions that I will be mentioning later. This project can be educative for people who are starting or currently using functional PL&amp;rsquo;s. I need to mention that this is an assignment done for a course in METU NCC. You can check full code here.
Table of contents  Preperation Construct The Tree Generate Height of the Tree Find the Weight of a Level in Tree Manual Traversal After Finding Declared Node Conclusion  Preperation Firstly I needed a custom Tree data type."
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://metekarasakal.me/blog/posts/recursive-positivetree-in-hs/" />





<link rel="stylesheet" href="https://metekarasakal.me/blog/assets/style.css" />

<link rel="stylesheet" href="https://metekarasakal.me/blog/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="https://metekarasakal.me/blog/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="https://metekarasakal.me/blog/img/favicon.png" />


<link href="https://metekarasakal.me/blog/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://metekarasakal.me/blog/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://metekarasakal.me/blog/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://metekarasakal.me/blog/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://metekarasakal.me/blog/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://metekarasakal.me/blog/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Positive Tree In Haskell"/>
<meta name="twitter:description" content="Introduction ðŸŒ² This is a project builds positive tree by adding/multiplying elements in pairs from bottom to top and there are functions that I will be mentioning later. This project can be educative for people who are starting or currently using functional PL&rsquo;s. I need to mention that this is an assignment done for a course in METU NCC. You can check full code here.
Table of contents  Preperation Construct The Tree Generate Height of the Tree Find the Weight of a Level in Tree Manual Traversal After Finding Declared Node Conclusion  Preperation Firstly I needed a custom Tree data type."/>



<meta property="og:title" content="Positive Tree In Haskell" />
<meta property="og:description" content="Introduction ðŸŒ² This is a project builds positive tree by adding/multiplying elements in pairs from bottom to top and there are functions that I will be mentioning later. This project can be educative for people who are starting or currently using functional PL&rsquo;s. I need to mention that this is an assignment done for a course in METU NCC. You can check full code here.
Table of contents  Preperation Construct The Tree Generate Height of the Tree Find the Weight of a Level in Tree Manual Traversal After Finding Declared Node Conclusion  Preperation Firstly I needed a custom Tree data type." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://metekarasakal.me/blog/posts/recursive-positivetree-in-hs/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-29T00:00:00&#43;03:00" />
<meta property="article:modified_time" content="2021-04-29T00:00:00&#43;03:00" /><meta property="og:site_name" content="DevBlog" />







  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="../../"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Mete Karasakal&#39;s DevBlog</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://metekarasakal.me/">About</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://metekarasakal.me/">About</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Positive Tree In Haskell</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2021-04-29
        </span>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <h2 id="introduction-">Introduction ðŸŒ²</h2>
<p>This is a project builds positive tree by adding/multiplying elements in pairs from bottom to top and there are functions that I will be mentioning later. This project can be educative for people who are starting or currently using functional PL&rsquo;s. I need to mention that this is an assignment done for a course in METU NCC. You can check full code <a href="https://github.com/patern0ster/functional-positive-tree-adt">here</a>.</p>
<h3 id="table-of-contents">Table of contents</h3>
<ol>
<li><a href="#preperation">Preperation</a></li>
<li><a href="#construct-the-tree">Construct The Tree</a></li>
<li><a href="#generate-height-of-the-tree">Generate Height of the Tree</a></li>
<li><a href="#find-the-weight-of-a-level-in-tree">Find the Weight of a Level in Tree</a></li>
<li><a href="#manual-traversal-after-finding-declared-node">Manual Traversal After Finding Declared Node</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2 id="preperation">Preperation</h2>
<p>Firstly I needed a custom Tree data type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Tree</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">NotFullBinary</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Leaf</span> a <span style="color:#f92672">|</span> <span style="color:#66d9ef">Node</span> a (<span style="color:#66d9ef">Tree</span> a) (<span style="color:#66d9ef">Tree</span> a) <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Show</span>, <span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Ord</span>)
</code></pre></div><p>I didn&rsquo;t used <em>Int</em> or <em>Float</em> I used <em>a</em> instead because it is polymorphic. <em>NotFullBinary</em> is for checking if a tree is valid to become positive tree or not. There are some helper functions represented below I recommend that you check these functions while reading the document.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">--To get right or left Leaf&#39;s value easier</span>
<span style="color:#a6e22e">right</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Node</span> c <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>)) <span style="color:#f92672">=</span> c
<span style="color:#a6e22e">right</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Leaf</span> c)) <span style="color:#f92672">=</span> c
<span style="color:#a6e22e">left</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Node</span> b <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>) <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> b
<span style="color:#a6e22e">left</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> (<span style="color:#66d9ef">Leaf</span> b) <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> b
<span style="color:#a6e22e">selfval</span> (<span style="color:#66d9ef">Node</span> a <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> a
<span style="color:#a6e22e">selfval</span> (<span style="color:#66d9ef">Leaf</span> a) <span style="color:#f92672">=</span> a


<span style="color:#75715e">--To traverse right or left leaves</span>
<span style="color:#a6e22e">rightleaf</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> c) <span style="color:#f92672">=</span> c
<span style="color:#a6e22e">rightleaf</span> <span style="color:#66d9ef">NotFullBinary</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">NotFullBinary</span>
<span style="color:#a6e22e">leftleaf</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> b <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> b
<span style="color:#a6e22e">leftleaf</span> <span style="color:#66d9ef">NotFullBinary</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">NotFullBinary</span>


<span style="color:#75715e">--Making calculations easier in positivetree func</span>
<span style="color:#a6e22e">calc</span> x op y <span style="color:#f92672">=</span>   <span style="color:#66d9ef">if</span> op <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>
                    <span style="color:#66d9ef">then</span> x<span style="color:#f92672">*</span>y
                <span style="color:#66d9ef">else</span>
                    x<span style="color:#f92672">+</span>y
</code></pre></div><p>Helper functions above are for general use except <em>calc</em>.</p>
<h2 id="construct-the-tree">Construct The Tree</h2>
<p><img src="https://i.ibb.co/q18gBTM/Screenshot-from-2021-04-27-18-11-18.png" alt="TreeExplain"><br>
As you can see in the image this function is for adding (or multiplying) elements in pairs of leaves and construct upward. Functions arguments are <em><strong>2d array</strong></em> and <em><strong>operation</strong></em> we will use. With these arguements function starts to build the tree from down to up.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">positivetree</span> xs op <span style="color:#f92672">=</span><span style="color:#66d9ef">if</span> length xs <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> head (head xs) <span style="color:#f92672">/=</span> <span style="color:#ae81ff">0</span><span style="color:#75715e">--It is base case in case func reaches bottom this case executes</span>
                        <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">Leaf</span> (head <span style="color:#f92672">$</span> head xs)
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> mod (length (last xs)) <span style="color:#ae81ff">2</span> <span style="color:#f92672">/=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">-- checks if it is an eligible list</span>
                        <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">NotFullBinary</span>
                    <span style="color:#66d9ef">else</span>
                        <span style="color:#66d9ef">Node</span> (calc (left (positivetree xs op)) op (right (positivetree xs op))) (positivetree (dropper xs <span style="color:#ae81ff">0</span>) op) (positivetree (dropper xs <span style="color:#ae81ff">1</span>) op)<span style="color:#75715e">--recurses trough tree and builds the tree</span>

</code></pre></div><p>This is the part that builds tree but to recurse I needed to drop elements carefully so I build dropper function which is needed but I could get arguments in other way for ease of read.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">dropper</span> (x<span style="color:#66d9ef">:</span>xs) side <span style="color:#f92672">=</span>   <span style="color:#66d9ef">if</span> side <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#75715e">--if side equals 0 this means it is left side</span>
                        <span style="color:#66d9ef">then</span> [drop (length (head xs) <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>(length x)) (head xs)] <span style="color:#f92672">++</span> (tail xs)<span style="color:#75715e">--makes the first arrays&#39; first element left of a node</span>
                        <span style="color:#66d9ef">else</span>
                            [drop (length (head xs) <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>(length x) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) (head xs)] <span style="color:#f92672">++</span> (tail xs)<span style="color:#75715e">--makes the first arrays&#39; first element right of a node</span>

</code></pre></div><p><img src="https://i.ibb.co/www9x4z/Screenshot-from-2021-04-27-18-14-50.png" alt="Samplepositivetree"><br>
You can see the test cases above for <strong>positivetree</strong> function.</p>
<h2 id="generate-height-of-the-tree">Generate Height of the Tree</h2>
<p>This function finds the longest way from top to bottom. It has only one arguement <em><strong>Tree</strong></em>. This is a really basic function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">generateheight</span> (<span style="color:#66d9ef">Leaf</span> <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#75715e">--base case of generateheight adds 1 when leafs reached</span>
<span style="color:#a6e22e">generateheight</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> left right) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max (generateheight left) (generateheight right)<span style="color:#75715e">--takes maximum length by traversing both right and left nodes of tree</span>
</code></pre></div><p><img src="https://i.ibb.co/0Qg1J8j/Screenshot-from-2021-04-27-18-28-55.png" alt="Samplegenerateheight"><br>
You can see the test cases above for <strong>generateheight</strong> function.</p>
<h2 id="find-the-weight-of-a-level-in-tree">Find the Weight of a Level in Tree</h2>
<p>This function finds the weight of a level in tree which means that it adds the elements in the declared level. You can ask why do you have this function just find it by using array but this function takes <em><strong>Tree</strong></em> and <em><strong>Level</strong></em> as arguments. Returns 0 if level is out of range.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">levelweight</span> (<span style="color:#66d9ef">Leaf</span> a) <span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> a <span style="color:#75715e">-- When level be calculated reached if we have Leaf in our hands</span>
<span style="color:#a6e22e">levelweight</span> (<span style="color:#66d9ef">Leaf</span> a) <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">-- If level is not reached yet return 0</span>
<span style="color:#a6e22e">levelweight</span> (<span style="color:#66d9ef">Node</span> a <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>) <span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> a <span style="color:#75715e">-- When level be calculated reached if we have Node in our hands</span>
<span style="color:#a6e22e">levelweight</span> (<span style="color:#66d9ef">Node</span> <span style="color:#66d9ef">_</span> left right) level <span style="color:#f92672">=</span> levelweight left (level<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> levelweight right (level<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e">--Goes to declared layer of the tree and sum the elements on that level</span>
</code></pre></div><p><img src="https://i.ibb.co/D98sKc1/Screenshot-from-2021-04-27-18-46-54.png" alt="Samplelevelweight"><br>
You can see the test cases above for <strong>levelweight</strong> function.</p>
<h2 id="manual-traversal-after-finding-declared-node">Manual Traversal After Finding Declared Node</h2>
<p><strong>manualtraversal</strong> function gets 3 arguments <em><strong>Tree</strong></em>, <em><strong>Nodes' value it seeks</strong></em>, and <em><strong>String consists of L and R</strong></em> after function finds the Node with declared value it starts to traverse manually &lsquo;L&rsquo; for left, &lsquo;R&rsquo; for right. In this function I am asked to declare another custom data type and return that data type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Traverse</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">NodeNotFound</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">StoppedEarly</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Found</span> a <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Show</span>, <span style="color:#66d9ef">Eq</span>, <span style="color:#66d9ef">Ord</span>)
</code></pre></div><p>In <em>Traverse</em> there are 3 states if there is no such node in the tree manualtraversal function returns <strong>NodeNotFound</strong>, if there is nowhere left to traverse it returns <strong>StoppedEarly</strong> and if the node or leaf is found returns <strong>Found a</strong>. I have 2 helper functions for manualtraversal (Recommended to check while reading <em>manualtraversal</em> function):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">--foundadd is used in manualtraversal to do recursive calculation</span>
<span style="color:#a6e22e">foundadd</span> (<span style="color:#66d9ef">Found</span> a) (<span style="color:#66d9ef">Found</span> b) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Found</span> (a<span style="color:#f92672">+</span>b)
<span style="color:#a6e22e">foundadd</span> (<span style="color:#66d9ef">NodeNotFound</span>) x <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">StoppedEarly</span> <span style="color:#f92672">&amp;&amp;</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">NodeNotFound</span>
                                <span style="color:#66d9ef">then</span> foundadd x (<span style="color:#66d9ef">Found</span> <span style="color:#ae81ff">0</span>)
                            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">NodeNotFound</span>
<span style="color:#a6e22e">foundadd</span> x (<span style="color:#66d9ef">NodeNotFound</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">StoppedEarly</span> <span style="color:#f92672">&amp;&amp;</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">NodeNotFound</span>
                                <span style="color:#66d9ef">then</span> foundadd x (<span style="color:#66d9ef">Found</span> <span style="color:#ae81ff">0</span>)
                            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">NodeNotFound</span>
<span style="color:#a6e22e">foundadd</span> (<span style="color:#66d9ef">StoppedEarly</span>) x <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">StoppedEarly</span> <span style="color:#f92672">&amp;&amp;</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">NodeNotFound</span>
                                <span style="color:#66d9ef">then</span> foundadd x (<span style="color:#66d9ef">Found</span> <span style="color:#ae81ff">0</span>)
                            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">StoppedEarly</span>
<span style="color:#a6e22e">foundadd</span> x (<span style="color:#66d9ef">StoppedEarly</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">StoppedEarly</span> <span style="color:#f92672">&amp;&amp;</span> x<span style="color:#f92672">/=</span><span style="color:#66d9ef">NodeNotFound</span>
                                <span style="color:#66d9ef">then</span> foundadd x (<span style="color:#66d9ef">Found</span> <span style="color:#ae81ff">0</span>)
                            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">StoppedEarly</span>

<span style="color:#75715e">--basically if type is leaf returns 0 and if type is Node returns 1</span>
<span style="color:#a6e22e">typefind</span> (<span style="color:#66d9ef">Node</span> a <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">typefind</span> (<span style="color:#66d9ef">Leaf</span> a) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><p>I already described what <em>manualtraversal</em> function does and here is the code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">manualtraversal</span> (<span style="color:#66d9ef">Leaf</span> a) (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Found</span> a
<span style="color:#a6e22e">manualtraversal</span> (<span style="color:#66d9ef">Node</span> a <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span>) (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">[]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Found</span> a
<span style="color:#75715e">--After finding number we are looking for func below to start traversing</span>
<span style="color:#75715e">--Manual traversal function after finding the declared number on tree traverse manually L for left R for right</span>
<span style="color:#a6e22e">manualtraversal</span> (<span style="color:#66d9ef">Node</span> a l r) (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) (s<span style="color:#66d9ef">:</span>str) <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;L&#39;</span>
                                                <span style="color:#66d9ef">then</span> manualtraversal l (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) str
                                            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;R&#39;</span>
                                                <span style="color:#66d9ef">then</span> manualtraversal r (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) str
                                            <span style="color:#66d9ef">else</span> manualtraversal (<span style="color:#66d9ef">Node</span> a l r) (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) str
<span style="color:#75715e">--If we have a leaf and traverse haven&#39;t started and num is equal to our leafs number it can&#39;t go anywhere it stops early</span>
<span style="color:#a6e22e">manualtraversal</span> (<span style="color:#66d9ef">Leaf</span> a) num str <span style="color:#f92672">=</span>  <span style="color:#66d9ef">StoppedEarly</span>
<span style="color:#75715e">-- When related node found number turns into -1 because of we have positive tree it can be used to change the state to start traversal</span>
<span style="color:#a6e22e">manualtraversal</span> (<span style="color:#66d9ef">Node</span> a l r) num str <span style="color:#f92672">=</span>  <span style="color:#66d9ef">if</span> a <span style="color:#f92672">==</span> num
                                            <span style="color:#66d9ef">then</span> manualtraversal (<span style="color:#66d9ef">Node</span> a l r) (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) str
                                        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> a <span style="color:#f92672">/=</span> num <span style="color:#f92672">&amp;&amp;</span> typefind l <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> typefind r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
                                            <span style="color:#66d9ef">then</span> <span style="color:#66d9ef">NodeNotFound</span>
                                        <span style="color:#66d9ef">else</span>
                                            foundadd (manualtraversal l num str) (manualtraversal r num str)
</code></pre></div><p><img src="https://i.ibb.co/HdZQxRY/Screenshot-from-2021-04-27-20-48-40.png" alt="Samplepositivetree"></p>
<p>You can see the test cases above for <strong>manualtraversal</strong> function.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Thank you for reading this document to the end. Sorry for inconsistency in my English currently I am in a tight schedule but I wanted to post a blog post so I couldn&rsquo;t have time to check grammar and vocabulary. I hope you understood well.</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
            
              <span class="button next">
                <a href="https://metekarasakal.me/blog/posts/firstpost/">
                  <span class="button__text">What topics will be included in this blog?</span>
                  <span class="button__icon">â†’</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="../../"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Mete Karasakal&#39;s DevBlog</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span
          >Â© 2021 Powered by
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span
        >
        <span
          >Theme created by
          <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span
        >
      </div>
    
  </div>
</footer>

<script src="https://metekarasakal.me/blog/assets/main.js"></script>
<script src="https://metekarasakal.me/blog/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
